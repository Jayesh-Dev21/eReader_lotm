<task>
Build a complete Android Kotlin app: a Kindle-style offline book reader for "Lord of the Mysteries" novel.
</task>

<architecture>
- Language: Kotlin
- UI: Jetpack Compose (Material 3, clean/sleek design)
- Data: Room Database for offline chapter storage
- Scraping: One-time fetch with Jsoup + Retrofit, then fully offline
- Navigation: Jetpack Navigation Compose
- State: ViewModel + StateFlow
- Persistence: DataStore for last-read position and reading preferences
</architecture>

<core_requirements>
1. SCRAPING STRATEGY:
   - Fetch all chapters from https://ranobes.top/novels/133485-lord-of-the-mysteries-v812312.html ONCE
   - Parse HTML with Jsoup to extract: book title, chapter titles, chapter content
   - Store all chapters in Room DB (Chapter entity: id, title, content, orderIndex)
   - After initial scrape, app is 100% offline
   - Include a Bash script (scrape_and_populate.sh) that:
     * Takes novel URL as input
     * Outputs structured data (JSON/CSV)
     * Can be reused for adding new books to the database

2. OFFLINE-FIRST DESIGN:
   - No network calls after initial data population
   - All reading from local Room DB
   - App should work in airplane mode

3. READING FEATURES:
   - Chapter list screen (scrollable list, shows chapter number + title)
   - Reader screen with TWO READING MODES (user-selectable in settings):
     
     MODE A: CONTINUOUS SCROLL (default)
     * Infinite vertical scroll through current chapter
     * When reaching end of chapter, automatically load next chapter seamlessly
     * Single continuous LazyColumn that appends next chapter content
     * Chapter title dividers between chapters
     * Smooth scrolling experience (like reading a single long document)
     
     MODE B: PAGINATED (page-flip style)
     * Content divided into screen-sized pages
     * Swipe left/right OR tap screen edges to flip pages
     * Page indicator (e.g., "Page 3/15" for current chapter)
     * At end of chapter, swipe loads next chapter
     * Optional page-flip animation (curl effect or simple fade)
   
   - Both modes share:
     * Swipe left/right OR tap edges to go next/previous chapter (when enabled in settings)
     * Chapter title displayed at top (can hide on tap)
     * Progress indicator (current chapter X/Y, reading percentage)
     * Tap center of screen to show/hide UI controls (immersive mode)
   
   - Font size adjustment: Slider (12sp to 28sp)
   - Theme toggle: Light + Dark (Material 3 themes, clean aesthetic)
   - Font family selector: Serif, Sans-serif, Monospace
   - Save last-read position: 
     * For scroll mode: chapter ID + scroll offset in pixels
     * For paginated mode: chapter ID + page number
     * Auto-save on scroll/page change (debounced)

4. UI/UX REQUIREMENTS:
   - Minimal, clean design (inspired by Kindle)
   - Bottom navigation or drawer for: Library, Reader, Settings
   - Settings screen for:
     * Reading mode: Toggle between Continuous Scroll / Paginated
     * Font size slider
     * Font family dropdown
     * Theme toggle (Light/Dark)
     * Navigation gestures: Enable/disable swipe or tap edges for chapter navigation
   - Reading screen hides UI chrome on center tap (immersive mode)
   - Smooth animations (chapter transitions, theme changes, mode switching)
   - Visual indicator when switching from scroll to paginated mode (brief toast/snackbar)

5. CODE STRUCTURE:
   Generate complete code files with TODO comments for Copilot expansion:
   
   /app/src/main/java/com/reader/lotm/
   ├── data/
   │   ├── local/
   │   │   ├── AppDatabase.kt          // Room database
   │   │   ├── ChapterDao.kt           // DAO for chapters
   │   │   ├── ChapterEntity.kt        // Chapter table model
   │   │   └── DataStoreManager.kt     // Save reading progress & preferences
   │   ├── repository/
   │   │   └── BookRepository.kt       // Abstraction layer
   │   ├── scraper/
   │   │   └── NovelScraper.kt         // Jsoup HTML parsing logic
   │   └── models/
   │       ├── ReadingMode.kt          // Enum: CONTINUOUS_SCROLL, PAGINATED
   │       └── ReadingPreferences.kt   // Data class for user settings
   ├── ui/
   │   ├── theme/
   │   │   ├── Theme.kt                // Material 3 Light/Dark
   │   │   ├── Color.kt
   │   │   └── Type.kt
   │   ├── screens/
   │   │   ├── ChapterListScreen.kt    // Browse chapters
   │   │   ├── ReaderScreen.kt         // Main reading view (mode-aware)
   │   │   └── SettingsScreen.kt       // Font/theme/mode controls
   │   ├── components/
   │   │   ├── ChapterItem.kt          // List item composable
   │   │   ├── ReadingControls.kt      // Font size slider, etc.
   │   │   ├── ContinuousReader.kt     // Infinite scroll implementation
   │   │   ├── PaginatedReader.kt      // Page-flip implementation
   │   │   └── ProgressIndicator.kt    // Chapter/page progress display
   │   └── viewmodels/
   │       ├── ChapterListViewModel.kt
   │       ├── ReaderViewModel.kt      // Handles both reading modes
   │       └── SettingsViewModel.kt    // Manages preferences
   ├── navigation/
   │   └── NavGraph.kt                 // Navigation setup
   ├── utils/
   │   ├── TextPaginator.kt            // Calculates text pages for paginated mode
   │   └── GestureDetector.kt          // Tap/swipe gesture handling
   └── MainActivity.kt                 // Entry point

   /scripts/
   └── scrape_and_populate.sh          // Bash script for reproducible scraping

   /docs/
   └── IMPLEMENTATION.md               // Markdown doc explaining all components
</core_requirements>

<technical_specifications>
- Min SDK: 26 (Android 8.0)
- Target SDK: 34
- Gradle dependencies (include in build.gradle.kts):
  * Jetpack Compose BOM
  * Room (KSP processor)
  * DataStore Preferences
  * Retrofit + OkHttp (for initial scrape only)
  * Jsoup (HTML parsing)
  * Navigation Compose
  * ViewModel + Lifecycle
  * Coroutines + Flow
  * Accompanist Pager (for swipe gestures in paginated mode, optional)

- Manifest permissions:
  * INTERNET (for one-time scrape)
  * Optional: WRITE_EXTERNAL_STORAGE (for export feature)

- Key implementation details:
  
  CONTINUOUS SCROLL MODE:
  * Use LazyColumn with multiple chapter items
  * Detect scroll position approaching end, preload next chapter
  * Use derivedStateOf for scroll position tracking
  * Chapter boundaries marked with subtle dividers
  
  PAGINATED MODE:
  * Use HorizontalPager or custom gesture detection
  * Calculate pages based on screen height and text size
  * TextPaginator.kt splits chapter text into page-sized chunks
  * Use Canvas or Text with maxLines to fit text per page
  * Save current page number in DataStore
  
  SHARED FEATURES:
  * Auto-save reading position with debounce (save every 2 seconds)
  * Use rememberSaveable for configuration changes
  * Implement proper error handling (try-catch, sealed Result class)
  * Smooth mode switching: preserve chapter position when toggling modes
  * Gesture detection: distinguish between tap (show/hide UI) and swipe (navigate)
</technical_specifications>

<bash_script_requirements>
The scrape_and_populate.sh script should:
1. Accept novel URL as argument: ./scrape_and_populate.sh <URL>
2. Use curl + jq OR a simple Kotlin script to:
   - Fetch HTML
   - Parse with Jsoup-equivalent (or call a minimal Kotlin CLI tool)
   - Output JSON: {"title": "...", "chapters": [{"id":1,"title":"...","content":"..."}]}
3. Insert data into Room DB (via adb + SQL insert OR by generating a prepopulated DB file)
4. Be reusable for other novels (generic HTML parsing with selectors as variables)
</bash_script_requirements>

<reading_mode_implementation_details>
CONTINUOUS SCROLL MODE:
- LazyColumn with items from current chapter + next chapter(s)
- Dynamically append chapters as user scrolls (infinite scroll pattern)
- Track scroll offset in pixels
- Show subtle chapter title dividers

PAGINATED MODE:
- Split chapter text into pages using TextMeasurer
- Each page = screen height minus padding
- HorizontalPager for swipe gestures OR custom Box with gesture detection
- Display page number (e.g., "Chapter 5 - Page 3/12")
- Optional: Add page-turning animation (slide or curl)

MODE SWITCHING:
- When user changes mode in settings, calculate equivalent position:
  * Scroll → Paginated: Convert scroll offset to page number
  * Paginated → Scroll: Convert page number to scroll offset
- Preserve chapter ID always
- Show brief confirmation snackbar after mode switch
</reading_mode_implementation_details>

<output_format>
Generate ALL code files with:
- Complete, production-ready Kotlin code (no placeholders)
- TODO comments for future enhancements
- Proper error handling and edge cases
- No explanatory text in code files

ALSO generate a single IMPLEMENTATION.md file that explains:
- Project structure overview
- How each component works (Database, Scraper, UI, Navigation)
- Reading mode implementations (continuous vs paginated)
- How to run the app (setup, build, initial scrape)
- How to use the Bash script to add new books
- Architecture decisions (why Room, why offline-first, etc.)
- Future enhancement TODOs (search, annotations, multiple books, bookmarks)

Do NOT include explanations inline in code. All documentation goes in IMPLEMENTATION.md.
</output_format>

<success_criteria>
- App compiles and runs on Android 8.0+
- Initial scrape fetches all LoTM chapters successfully
- Fully functional offline after first launch
- Both reading modes work smoothly:
  * Continuous scroll loads chapters seamlessly
  * Paginated mode calculates pages correctly, flips smoothly
- Reading position persists across app restarts (respects current mode)
- Mode switching preserves approximate reading position
- Theme switch works instantly
- Font controls update live in both modes
- Bash script successfully adds new books when executed
</success_criteria>

<execution_instruction>
Generate the complete project. I will not intervene. Produce all files, code, and documentation now.
</execution_instruction>